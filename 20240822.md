# 2024-08-22  3차시 - 정렬2

## 선택 정렬 Selection Sort
리스트에서 **최솟값을 선택**하여 첫번째 요소와 교환하는 정렬 기법

1. 두개의 리스트를 사용한 선택정렬
    * 배열이 하나 더 필요함
    * 메모리 효율적이지 않음
2. 제자리 정렬
    * 메모리 효율적임

### 제자리 선택정렬 코드
```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define SWAP(x, y, t) ((t) = (x), (x) = (y), (y) = (t))
#define MAX_SIZE 10

int list[MAX_SIZE];
int n;

void selSort(int list[], int n)
{
    int i, j, least, temp;
    for (i = 0 ; i < n - 1 ; i++) {     //마지막 인덱스는 자신과 비교할 필요 없음 -> n - 1 까지 반복
        least = i;
        for (j = i + 1 ; j < n ; j++) {
            if (list[j] < list[least])      //최솟값 비교
                SWAP(list[i], list[j], temp);
                least = j;
        }
    }
}

int main()
{
    int i;
    n = MAX_SIZE;
    srand(time(NULL));
    for (i = 0 ; i < n ; i++)
        list[i] = rand() % 100; // 난수 발생 범위 0 ~ 99
    printf("** Selection Sort **\n\n");
    printf("Before Sorting\n");
    for (i = 0 ; i < n ; i++) // 정렬 전
        printf("%d ", list[i]);
    selSort(list, n); // 정렬
    printf("\n\nAfter Sorting\n");
    for (i = 0 ; i < n ; i++) // 정렬 후
        printf("%d ", list[i]);
    printf("\n");
    return 0;
}
```
[참고: https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html](https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html)

### 이 코드의 시간복잡도 분석
* 비교 횟수
    * if 가 이중 for 문 안에 있다 -> n^2
* 이동 횟수
    * SWAP이 for 문 안에 있는데 SWAP 은 3개의 연산 -> 3 * (n - 1)
* 안정성?